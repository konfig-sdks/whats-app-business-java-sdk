/*
 * WhatsApp Business API
 * See https://developers.facebook.com/docs/whatsapp
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.konfigthis.client.model.Media;
import com.konfigthis.client.model.Webhooks;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.konfigthis.client.JSON;

/**
 * ApplicationSettings
 */@javax.annotation.Generated(value = "Generated by https://konfigthis.com")
public class ApplicationSettings {
  public static final String SERIALIZED_NAME_CALLBACK_BACKOFF_DELAY_MS = "callback_backoff_delay_ms";
  @SerializedName(SERIALIZED_NAME_CALLBACK_BACKOFF_DELAY_MS)
  private String callbackBackoffDelayMs = "3000";

  public static final String SERIALIZED_NAME_CALLBACK_PERSIST = "callback_persist";
  @SerializedName(SERIALIZED_NAME_CALLBACK_PERSIST)
  private Boolean callbackPersist = true;

  public static final String SERIALIZED_NAME_HEARTBEAT_INTERVAL = "heartbeat_interval";
  @SerializedName(SERIALIZED_NAME_HEARTBEAT_INTERVAL)
  private Integer heartbeatInterval = 5;

  public static final String SERIALIZED_NAME_MAX_CALLBACK_BACKOFF_DELAY_MS = "max_callback_backoff_delay_ms";
  @SerializedName(SERIALIZED_NAME_MAX_CALLBACK_BACKOFF_DELAY_MS)
  private String maxCallbackBackoffDelayMs = "900000";

  public static final String SERIALIZED_NAME_MEDIA = "media";
  @SerializedName(SERIALIZED_NAME_MEDIA)
  private Media media;

  public static final String SERIALIZED_NAME_ON_CALL_PAGER = "on_call_pager";
  @SerializedName(SERIALIZED_NAME_ON_CALL_PAGER)
  private String onCallPager;

  public static final String SERIALIZED_NAME_PASS_THROUGH = "pass_through";
  @SerializedName(SERIALIZED_NAME_PASS_THROUGH)
  private Boolean passThrough = true;

  public static final String SERIALIZED_NAME_SENT_STATUS = "sent_status";
  @SerializedName(SERIALIZED_NAME_SENT_STATUS)
  private Boolean sentStatus = false;

  public static final String SERIALIZED_NAME_UNHEALTHY_INTERVAL = "unhealthy_interval";
  @SerializedName(SERIALIZED_NAME_UNHEALTHY_INTERVAL)
  private Integer unhealthyInterval = 30;

  public static final String SERIALIZED_NAME_WEBHOOKS = "webhooks";
  @SerializedName(SERIALIZED_NAME_WEBHOOKS)
  private Webhooks webhooks;

  public ApplicationSettings() {
  }

  public ApplicationSettings callbackBackoffDelayMs(String callbackBackoffDelayMs) {
    
    
    
    
    this.callbackBackoffDelayMs = callbackBackoffDelayMs;
    return this;
  }

   /**
   * Backoff delay for a failed callback in milliseconds This setting is used to configure the amount of time the backoff delays before retrying a failed callback. The backoff delay increases linearly by this value each time a callback fails to get a HTTPS 200 OK response. The backoff delay is capped by the max_callback_backoff_delay_ms setting.
   * @return callbackBackoffDelayMs
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "3000", value = "Backoff delay for a failed callback in milliseconds This setting is used to configure the amount of time the backoff delays before retrying a failed callback. The backoff delay increases linearly by this value each time a callback fails to get a HTTPS 200 OK response. The backoff delay is capped by the max_callback_backoff_delay_ms setting.")

  public String getCallbackBackoffDelayMs() {
    return callbackBackoffDelayMs;
  }


  public void setCallbackBackoffDelayMs(String callbackBackoffDelayMs) {
    
    
    
    this.callbackBackoffDelayMs = callbackBackoffDelayMs;
  }


  public ApplicationSettings callbackPersist(Boolean callbackPersist) {
    
    
    
    
    this.callbackPersist = callbackPersist;
    return this;
  }

   /**
   * Stores callbacks on disk until they are successfully acknowledged by the Webhook or not. Restart required.
   * @return callbackPersist
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "true", value = "Stores callbacks on disk until they are successfully acknowledged by the Webhook or not. Restart required.")

  public Boolean getCallbackPersist() {
    return callbackPersist;
  }


  public void setCallbackPersist(Boolean callbackPersist) {
    
    
    
    this.callbackPersist = callbackPersist;
  }


  public ApplicationSettings heartbeatInterval(Integer heartbeatInterval) {
    
    
    
    
    this.heartbeatInterval = heartbeatInterval;
    return this;
  }

   /**
   * Multiconnect: Interval of the Master node monitoring of Coreapp nodes in seconds
   * @return heartbeatInterval
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "5", value = "Multiconnect: Interval of the Master node monitoring of Coreapp nodes in seconds")

  public Integer getHeartbeatInterval() {
    return heartbeatInterval;
  }


  public void setHeartbeatInterval(Integer heartbeatInterval) {
    
    
    
    this.heartbeatInterval = heartbeatInterval;
  }


  public ApplicationSettings maxCallbackBackoffDelayMs(String maxCallbackBackoffDelayMs) {
    
    
    
    
    this.maxCallbackBackoffDelayMs = maxCallbackBackoffDelayMs;
    return this;
  }

   /**
   * Maximum delay for a failed callback in milliseconds
   * @return maxCallbackBackoffDelayMs
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "900000", value = "Maximum delay for a failed callback in milliseconds")

  public String getMaxCallbackBackoffDelayMs() {
    return maxCallbackBackoffDelayMs;
  }


  public void setMaxCallbackBackoffDelayMs(String maxCallbackBackoffDelayMs) {
    
    
    
    this.maxCallbackBackoffDelayMs = maxCallbackBackoffDelayMs;
  }


  public ApplicationSettings media(Media media) {
    
    
    
    
    this.media = media;
    return this;
  }

   /**
   * Get media
   * @return media
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Media getMedia() {
    return media;
  }


  public void setMedia(Media media) {
    
    
    
    this.media = media;
  }


  public ApplicationSettings onCallPager(String onCallPager) {
    
    
    
    
    this.onCallPager = onCallPager;
    return this;
  }

   /**
   * Set to valid WhatsApp Group with users who wish to see alerts for critical errors and messages.
   * @return onCallPager
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "<WA_ID of valid WhatsApp contact>", value = "Set to valid WhatsApp Group with users who wish to see alerts for critical errors and messages.")

  public String getOnCallPager() {
    return onCallPager;
  }


  public void setOnCallPager(String onCallPager) {
    
    
    
    this.onCallPager = onCallPager;
  }


  public ApplicationSettings passThrough(Boolean passThrough) {
    
    
    
    
    this.passThrough = passThrough;
    return this;
  }

   /**
   * When true, removes messages from the local database after they are delivered to or read by the recipient. When false, saves all messages on local storage until they are explicitly deleted. When messages are sent, they are stored in a local database. This database is used as the application&#39;s history. Since the business keeps its own history, you can specify whether you want message pass_through or not. Restart required.
   * @return passThrough
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "true", value = "When true, removes messages from the local database after they are delivered to or read by the recipient. When false, saves all messages on local storage until they are explicitly deleted. When messages are sent, they are stored in a local database. This database is used as the application's history. Since the business keeps its own history, you can specify whether you want message pass_through or not. Restart required.")

  public Boolean getPassThrough() {
    return passThrough;
  }


  public void setPassThrough(Boolean passThrough) {
    
    
    
    this.passThrough = passThrough;
  }


  public ApplicationSettings sentStatus(Boolean sentStatus) {
    
    
    
    
    this.sentStatus = sentStatus;
    return this;
  }

   /**
   * Receive a notification that a message is sent to server. When true, you will receive a message indicating that a message has been sent. If false (default), you will not receive notification.
   * @return sentStatus
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "false", value = "Receive a notification that a message is sent to server. When true, you will receive a message indicating that a message has been sent. If false (default), you will not receive notification.")

  public Boolean getSentStatus() {
    return sentStatus;
  }


  public void setSentStatus(Boolean sentStatus) {
    
    
    
    this.sentStatus = sentStatus;
  }


  public ApplicationSettings unhealthyInterval(Integer unhealthyInterval) {
    
    
    
    
    this.unhealthyInterval = unhealthyInterval;
    return this;
  }

   /**
   * Multiconnect: Maximum amount of seconds a Master node waits for a Coreapp node to respond to a heartbeat before considering it unhealthy and starting the failover process.
   * @return unhealthyInterval
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "30", value = "Multiconnect: Maximum amount of seconds a Master node waits for a Coreapp node to respond to a heartbeat before considering it unhealthy and starting the failover process.")

  public Integer getUnhealthyInterval() {
    return unhealthyInterval;
  }


  public void setUnhealthyInterval(Integer unhealthyInterval) {
    
    
    
    this.unhealthyInterval = unhealthyInterval;
  }


  public ApplicationSettings webhooks(Webhooks webhooks) {
    
    
    
    
    this.webhooks = webhooks;
    return this;
  }

   /**
   * Get webhooks
   * @return webhooks
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Webhooks getWebhooks() {
    return webhooks;
  }


  public void setWebhooks(Webhooks webhooks) {
    
    
    
    this.webhooks = webhooks;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the ApplicationSettings instance itself
   */
  public ApplicationSettings putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ApplicationSettings applicationSettings = (ApplicationSettings) o;
    return Objects.equals(this.callbackBackoffDelayMs, applicationSettings.callbackBackoffDelayMs) &&
        Objects.equals(this.callbackPersist, applicationSettings.callbackPersist) &&
        Objects.equals(this.heartbeatInterval, applicationSettings.heartbeatInterval) &&
        Objects.equals(this.maxCallbackBackoffDelayMs, applicationSettings.maxCallbackBackoffDelayMs) &&
        Objects.equals(this.media, applicationSettings.media) &&
        Objects.equals(this.onCallPager, applicationSettings.onCallPager) &&
        Objects.equals(this.passThrough, applicationSettings.passThrough) &&
        Objects.equals(this.sentStatus, applicationSettings.sentStatus) &&
        Objects.equals(this.unhealthyInterval, applicationSettings.unhealthyInterval) &&
        Objects.equals(this.webhooks, applicationSettings.webhooks)&&
        Objects.equals(this.additionalProperties, applicationSettings.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(callbackBackoffDelayMs, callbackPersist, heartbeatInterval, maxCallbackBackoffDelayMs, media, onCallPager, passThrough, sentStatus, unhealthyInterval, webhooks, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ApplicationSettings {\n");
    sb.append("    callbackBackoffDelayMs: ").append(toIndentedString(callbackBackoffDelayMs)).append("\n");
    sb.append("    callbackPersist: ").append(toIndentedString(callbackPersist)).append("\n");
    sb.append("    heartbeatInterval: ").append(toIndentedString(heartbeatInterval)).append("\n");
    sb.append("    maxCallbackBackoffDelayMs: ").append(toIndentedString(maxCallbackBackoffDelayMs)).append("\n");
    sb.append("    media: ").append(toIndentedString(media)).append("\n");
    sb.append("    onCallPager: ").append(toIndentedString(onCallPager)).append("\n");
    sb.append("    passThrough: ").append(toIndentedString(passThrough)).append("\n");
    sb.append("    sentStatus: ").append(toIndentedString(sentStatus)).append("\n");
    sb.append("    unhealthyInterval: ").append(toIndentedString(unhealthyInterval)).append("\n");
    sb.append("    webhooks: ").append(toIndentedString(webhooks)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("callback_backoff_delay_ms");
    openapiFields.add("callback_persist");
    openapiFields.add("heartbeat_interval");
    openapiFields.add("max_callback_backoff_delay_ms");
    openapiFields.add("media");
    openapiFields.add("on_call_pager");
    openapiFields.add("pass_through");
    openapiFields.add("sent_status");
    openapiFields.add("unhealthy_interval");
    openapiFields.add("webhooks");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to ApplicationSettings
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!ApplicationSettings.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ApplicationSettings is not found in the empty JSON string", ApplicationSettings.openapiRequiredFields.toString()));
        }
      }
      if ((jsonObj.get("callback_backoff_delay_ms") != null && !jsonObj.get("callback_backoff_delay_ms").isJsonNull()) && !jsonObj.get("callback_backoff_delay_ms").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `callback_backoff_delay_ms` to be a primitive type in the JSON string but got `%s`", jsonObj.get("callback_backoff_delay_ms").toString()));
      }
      if ((jsonObj.get("max_callback_backoff_delay_ms") != null && !jsonObj.get("max_callback_backoff_delay_ms").isJsonNull()) && !jsonObj.get("max_callback_backoff_delay_ms").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `max_callback_backoff_delay_ms` to be a primitive type in the JSON string but got `%s`", jsonObj.get("max_callback_backoff_delay_ms").toString()));
      }
      // validate the optional field `media`
      if (jsonObj.get("media") != null && !jsonObj.get("media").isJsonNull()) {
        Media.validateJsonObject(jsonObj.getAsJsonObject("media"));
      }
      if ((jsonObj.get("on_call_pager") != null && !jsonObj.get("on_call_pager").isJsonNull()) && !jsonObj.get("on_call_pager").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `on_call_pager` to be a primitive type in the JSON string but got `%s`", jsonObj.get("on_call_pager").toString()));
      }
      // validate the optional field `webhooks`
      if (jsonObj.get("webhooks") != null && !jsonObj.get("webhooks").isJsonNull()) {
        Webhooks.validateJsonObject(jsonObj.getAsJsonObject("webhooks"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ApplicationSettings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ApplicationSettings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ApplicationSettings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ApplicationSettings.class));

       return (TypeAdapter<T>) new TypeAdapter<ApplicationSettings>() {
           @Override
           public void write(JsonWriter out, ApplicationSettings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additonal properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public ApplicationSettings read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             // store additional fields in the deserialized instance
             ApplicationSettings instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ApplicationSettings given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ApplicationSettings
  * @throws IOException if the JSON string is invalid with respect to ApplicationSettings
  */
  public static ApplicationSettings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ApplicationSettings.class);
  }

 /**
  * Convert an instance of ApplicationSettings to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

